//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: betting
// ----------------------------------------------------------------------------
pub mod betting {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for betting
    pub fn program_id() -> Pubkey {
        pubkey!("EuDe8zmbZeYuaADaJjp8F9zCHm9L7LuAvrsvqLdSCXN4")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: ClaimReward
    // ....................................................................

    /// Main instruction struct for ClaimReward
    pub struct ClaimRewardInstruction {
        pub accounts: ClaimRewardInstructionAccountMetas,
        pub data: ClaimRewardInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ClaimReward instruction
    #[derive(Debug, Clone, Default)]
    pub struct ClaimRewardInstructionAccountMetas {
        pub player: AccountMeta,

        pub vault_account: AccountMeta,

        pub bet_account: AccountMeta,

        pub event_account: AccountMeta,

        pub option_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for ClaimReward instruction
    #[derive(Debug, Clone)]
    pub struct ClaimRewardInstructionAccounts {
        pub player: Pubkey,

        pub vault_account: Pubkey,

        pub bet_account: Pubkey,

        pub event_account: Pubkey,

        pub option_account: Pubkey,
    }

    impl ClaimRewardInstructionAccounts {
        pub fn new(
            player: Pubkey,

            vault_account: Pubkey,

            bet_account: Pubkey,

            event_account: Pubkey,

            option_account: Pubkey,
        ) -> Self {
            Self {
                player,

                vault_account,

                bet_account,

                event_account,

                option_account,
            }
        }
    }

    /// Instruction data for ClaimReward
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ClaimRewardInstructionData {
        pub _event_id: u64,
    }

    impl ClaimRewardInstructionData {
        pub fn new(_event_id: u64) -> Self {
            Self { _event_id }
        }
    }

    /// Implementation for ClaimRewardInstruction
    impl ClaimRewardInstruction {
        fn discriminator() -> [u8; 8] {
            [149u8, 95u8, 181u8, 242u8, 94u8, 90u8, 158u8, 162u8]
        }

        pub fn data(data: ClaimRewardInstructionData) -> Self {
            Self {
                accounts: ClaimRewardInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ClaimRewardInstructionAccounts) -> Self {
            self.accounts.player = AccountMeta::new(accounts.player, true);

            self.accounts.vault_account = AccountMeta::new(accounts.vault_account, false);

            self.accounts.bet_account = AccountMeta::new(accounts.bet_account, false);

            self.accounts.event_account = AccountMeta::new(accounts.event_account, false);

            self.accounts.option_account = AccountMeta::new(accounts.option_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.player.clone());

            metas.push(self.accounts.vault_account.clone());

            metas.push(self.accounts.bet_account.clone());

            metas.push(self.accounts.event_account.clone());

            metas.push(self.accounts.option_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: InitializeEvent
    // ....................................................................

    /// Main instruction struct for InitializeEvent
    pub struct InitializeEventInstruction {
        pub accounts: InitializeEventInstructionAccountMetas,
        pub data: InitializeEventInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for InitializeEvent instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeEventInstructionAccountMetas {
        pub authority: AccountMeta,

        pub event_account: AccountMeta,

        pub vault_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for InitializeEvent instruction
    #[derive(Debug, Clone)]
    pub struct InitializeEventInstructionAccounts {
        pub authority: Pubkey,

        pub event_account: Pubkey,

        pub vault_account: Pubkey,
    }

    impl InitializeEventInstructionAccounts {
        pub fn new(authority: Pubkey, event_account: Pubkey, vault_account: Pubkey) -> Self {
            Self {
                authority,

                event_account,

                vault_account,
            }
        }
    }

    /// Instruction data for InitializeEvent
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeEventInstructionData {
        pub _event_id: u64,

        pub start_time: u64,

        pub end_time: u64,

        pub event_name: String,

        pub event_description: String,
    }

    impl InitializeEventInstructionData {
        pub fn new(
            _event_id: u64,

            start_time: u64,

            end_time: u64,

            event_name: String,

            event_description: String,
        ) -> Self {
            Self {
                _event_id,

                start_time,

                end_time,

                event_name,

                event_description,
            }
        }
    }

    /// Implementation for InitializeEventInstruction
    impl InitializeEventInstruction {
        fn discriminator() -> [u8; 8] {
            [126u8, 249u8, 86u8, 221u8, 202u8, 171u8, 134u8, 20u8]
        }

        pub fn data(data: InitializeEventInstructionData) -> Self {
            Self {
                accounts: InitializeEventInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeEventInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.event_account = AccountMeta::new(accounts.event_account, false);

            self.accounts.vault_account = AccountMeta::new(accounts.vault_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.event_account.clone());

            metas.push(self.accounts.vault_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: InitializeOptions
    // ....................................................................

    /// Main instruction struct for InitializeOptions
    pub struct InitializeOptionsInstruction {
        pub accounts: InitializeOptionsInstructionAccountMetas,
        pub data: InitializeOptionsInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for InitializeOptions instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeOptionsInstructionAccountMetas {
        pub authority: AccountMeta,

        pub option_account: AccountMeta,

        pub event_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for InitializeOptions instruction
    #[derive(Debug, Clone)]
    pub struct InitializeOptionsInstructionAccounts {
        pub authority: Pubkey,

        pub option_account: Pubkey,

        pub event_account: Pubkey,
    }

    impl InitializeOptionsInstructionAccounts {
        pub fn new(authority: Pubkey, option_account: Pubkey, event_account: Pubkey) -> Self {
            Self {
                authority,

                option_account,

                event_account,
            }
        }
    }

    /// Instruction data for InitializeOptions
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeOptionsInstructionData {
        pub _event_id: u64,

        pub option: String,
    }

    impl InitializeOptionsInstructionData {
        pub fn new(_event_id: u64, option: String) -> Self {
            Self { _event_id, option }
        }
    }

    /// Implementation for InitializeOptionsInstruction
    impl InitializeOptionsInstruction {
        fn discriminator() -> [u8; 8] {
            [240u8, 50u8, 104u8, 130u8, 252u8, 40u8, 11u8, 179u8]
        }

        pub fn data(data: InitializeOptionsInstructionData) -> Self {
            Self {
                accounts: InitializeOptionsInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeOptionsInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.option_account = AccountMeta::new(accounts.option_account, false);

            self.accounts.event_account = AccountMeta::new(accounts.event_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.option_account.clone());

            metas.push(self.accounts.event_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: PlaceBet
    // ....................................................................

    /// Main instruction struct for PlaceBet
    pub struct PlaceBetInstruction {
        pub accounts: PlaceBetInstructionAccountMetas,
        pub data: PlaceBetInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for PlaceBet instruction
    #[derive(Debug, Clone, Default)]
    pub struct PlaceBetInstructionAccountMetas {
        pub player: AccountMeta,

        pub event_account: AccountMeta,

        pub option_account: AccountMeta,

        pub vault_account: AccountMeta,

        pub bet_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for PlaceBet instruction
    #[derive(Debug, Clone)]
    pub struct PlaceBetInstructionAccounts {
        pub player: Pubkey,

        pub event_account: Pubkey,

        pub option_account: Pubkey,

        pub vault_account: Pubkey,

        pub bet_account: Pubkey,
    }

    impl PlaceBetInstructionAccounts {
        pub fn new(
            player: Pubkey,

            event_account: Pubkey,

            option_account: Pubkey,

            vault_account: Pubkey,

            bet_account: Pubkey,
        ) -> Self {
            Self {
                player,

                event_account,

                option_account,

                vault_account,

                bet_account,
            }
        }
    }

    /// Instruction data for PlaceBet
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PlaceBetInstructionData {
        pub _event_id: u64,

        pub option: String,

        pub amount: u64,
    }

    impl PlaceBetInstructionData {
        pub fn new(_event_id: u64, option: String, amount: u64) -> Self {
            Self {
                _event_id,

                option,

                amount,
            }
        }
    }

    /// Implementation for PlaceBetInstruction
    impl PlaceBetInstruction {
        fn discriminator() -> [u8; 8] {
            [222u8, 62u8, 67u8, 220u8, 63u8, 166u8, 126u8, 33u8]
        }

        pub fn data(data: PlaceBetInstructionData) -> Self {
            Self {
                accounts: PlaceBetInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PlaceBetInstructionAccounts) -> Self {
            self.accounts.player = AccountMeta::new(accounts.player, true);

            self.accounts.event_account = AccountMeta::new(accounts.event_account, false);

            self.accounts.option_account = AccountMeta::new(accounts.option_account, false);

            self.accounts.vault_account = AccountMeta::new(accounts.vault_account, false);

            self.accounts.bet_account = AccountMeta::new(accounts.bet_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.player.clone());

            metas.push(self.accounts.event_account.clone());

            metas.push(self.accounts.option_account.clone());

            metas.push(self.accounts.vault_account.clone());

            metas.push(self.accounts.bet_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ResolveEvent
    // ....................................................................

    /// Main instruction struct for ResolveEvent
    pub struct ResolveEventInstruction {
        pub accounts: ResolveEventInstructionAccountMetas,
        pub data: ResolveEventInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ResolveEvent instruction
    #[derive(Debug, Clone, Default)]
    pub struct ResolveEventInstructionAccountMetas {
        pub authority: AccountMeta,

        pub event_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for ResolveEvent instruction
    #[derive(Debug, Clone)]
    pub struct ResolveEventInstructionAccounts {
        pub authority: Pubkey,

        pub event_account: Pubkey,
    }

    impl ResolveEventInstructionAccounts {
        pub fn new(authority: Pubkey, event_account: Pubkey) -> Self {
            Self {
                authority,

                event_account,
            }
        }
    }

    /// Instruction data for ResolveEvent
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ResolveEventInstructionData {
        pub _event_id: u64,

        pub winning_option: String,
    }

    impl ResolveEventInstructionData {
        pub fn new(_event_id: u64, winning_option: String) -> Self {
            Self {
                _event_id,

                winning_option,
            }
        }
    }

    /// Implementation for ResolveEventInstruction
    impl ResolveEventInstruction {
        fn discriminator() -> [u8; 8] {
            [184u8, 55u8, 78u8, 47u8, 114u8, 38u8, 50u8, 90u8]
        }

        pub fn data(data: ResolveEventInstructionData) -> Self {
            Self {
                accounts: ResolveEventInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ResolveEventInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.event_account = AccountMeta::new(accounts.event_account, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.event_account.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: BetAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct BetAccount {
    pub player: Pubkey,

    pub event_id: u64,

    pub option: String,

    pub amount: u64,

    pub reward_claimed: bool,

    pub bet_placed: bool,
}

impl BetAccount {
    pub fn new(
        player: Pubkey,

        event_id: u64,

        option: String,

        amount: u64,

        reward_claimed: bool,

        bet_placed: bool,
    ) -> Self {
        Self {
            player,

            event_id,

            option,

            amount,

            reward_claimed,

            bet_placed,
        }
    }
}

/// Custom struct: EventAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct EventAccount {
    pub authority: Pubkey,

    pub event_name: String,

    pub event_description: String,

    pub betting_start: u64,

    pub betting_end: u64,

    pub betting_options_index: u64,

    pub event_resolved: bool,

    pub winning_option: String,

    pub total_pool: u64,
}

impl EventAccount {
    pub fn new(
        authority: Pubkey,

        event_name: String,

        event_description: String,

        betting_start: u64,

        betting_end: u64,

        betting_options_index: u64,

        event_resolved: bool,

        winning_option: String,

        total_pool: u64,
    ) -> Self {
        Self {
            authority,

            event_name,

            event_description,

            betting_start,

            betting_end,

            betting_options_index,

            event_resolved,

            winning_option,

            total_pool,
        }
    }
}

/// Custom struct: OptionAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct OptionAccount {
    pub option_name: String,

    pub option_votes: u64,

    pub option_pool: u64,
}

impl OptionAccount {
    pub fn new(option_name: String, option_votes: u64, option_pool: u64) -> Self {
        Self {
            option_name,

            option_votes,

            option_pool,
        }
    }
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
